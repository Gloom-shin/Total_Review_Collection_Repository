# 1주차 리뷰
<br>

## 코딩테스트 풀이

### 11.16 step1_그리디
#### 첫번째 기지국 문제
 - 문제를 읽고, 나는 먼저 가공해야할 데이터가 무엇일지 또 어떤 자료구조에 담아야 할 지 부터 생각하였다.
   - 기지국 문제이기에, 영역을 만들어 방문 유무를 파악해 가는 형태로 진행하였고 
   - 주어지는 변수의 범위가 너무 넓어 반복문이 2번 중첩되면 안된다는 것을 신경쓰면서 로직을 구현하였다.
 - 구현하다 보니, 방문 유무의 체크가 무의미하다는 것을 깨닫고 코드를 고쳐나아갔지만, 효율성 문제를 통과하지는 못했다.
#### 두번째 자전거 공장 문제 
 - 문제를 읽고 이것 역시 Greedy문제임은 파악 했다. 
 - 하지만, 어디서부터 최고의 이득을 보면서 나아가야할지 감이 잡히지 않았다. 

### 채점 결과 
 - 생각보다 2시간은 금방 지나갔고 1번문제는 효율성검사 실패, 2번문제는 예시도 풀지 못하였다. 
 - 다음엔 보다 긴장감을 가지고 온전히 집중할 수 있을 때 진지하게 임해야겠다는 생각이 들었다. 
 - 그리고 다시한번 문제를 풀어보고 싶었다.

<br>

### 11.17 step2_정렬
#### 첫번째 가장 큰수 
 - 문제를 보면, 주어진 수를 조합하여 가장 큰 수를 만드는 것이 목표이다.
   - 말그대로 처음에는 순열을 생각하여 최대값을 구하도록 코드를 짜려고 했으나, 시간복잡도 상 좋지않은 방법인 것 같아 포기하였다.
 - 그 다음으로 생각한 것은 맨 앞자리의 숫자를 비교하는 방식이었다. 
   - 숫자를 모두 문자열로 만들고 문자의 가장 앞자리를 내림차순으로 정렬하며, 문자열로 합치는 방법이다.
   - 물론 이 방법 또한 예외 케이스가 발생하여, 예외케이스를 찾아 대입해보며, 처리해보았다. 
   - 하지만 결론적으론 예외케이스를 다 찾지못해, 53.3점으로 마무리 되었다.
#### 두번째 마법의 엘리베이터
- 처음에는 문자열로 전환하여, 하나하나 체크해가며 문제를 풀어 가려고 했다. 
  - 여기서 중요한것은 앞에서 부터 볼것인지, 뒤에서 부터 볼것인지였는데 이것을 못 정하고 시뮬레이션을 계속 돌려봐서 오래걸렸다.
- 결국 뒤에서 부터 하나씩 보는 방식으로 정하였고, 자릿수별로 올림을 해줘야 되는 경우도 생기기 때문에 `Queue` 자료구조를 선택하여 사용하였다. 
- 1차적으로 제출결과 23점으로 결과가 참담하여, 예외 케이스를 찾아 적어가면서 처리하였다. 
  - 하지만, 약간의 시간부족으로 조급해지면서 결국 1솔하지는 못하였지만,
  - 이후, 다시 풀기에서는 예외케이스를 모두 해결하여 문제를 해결하였다.
- 최소갯수를 묻는 문제이다 보니 정렬보다는 그리디에 가까운 느낌이었다. 

<br>

### 11.19 step3_이분탐색
#### 첫번째 예산
 - 생각보다 어렵지 않았다. 읽고나서 정렬만 잘해도 풀리는 문제라는 것이 보였다.
   1. 부서별 신청한 금액 배열을 오름차순으로 정렬한다.
   2. 앞에서 부터 합으로 계산하고, 예산이 넘어가는 순간 인덱스를 반환한다. 
#### 두번째 공장관리
 - 시간이 많아서 충분히 풀수 있을 줄 알았지만, 효율성검사도 있어 쉽지않았다.
 - 주어진 조건을 보면 내가 핸들링해야될 요소가 시간임을 느끼고, 가장 오래걸릴 케이스와 가장 빠를 케이스를 계산하였다. 
   - 목표갯수/총 배열의 길이 = 각 배열 요소 하나마다 만들어야할 할당 갯 수
   - 최장시간, 최단시간을 mid를 만들어 이분탐색으로 풀이하였다.
### 채점결과
 - 1솔과 95.0점, 테스트 예제 하나 빼고 다 통과하였다. 



<br>
<br>

## 개념학습

### 11.16 step1
#### 지문 이해 및 풀이 계획강의
 - 지문 이해 및 풀이 계획 세우기는 내가 생각했던 방식과 크게 다를 것이 없었다.

#### 강사의 풀이
 - 하지만, 코드는 완전히 달랐다. 풀이 계획은 같지만 코드로 구현해내는 방식이 내가 많이 부족하다는 것을 깨닫는 시간이었다.
 - 나는 문제를 영역이나, 방문을 사용하여 해당 방문유무를 체크해가며 탐색을 이어갔지만 강사님의 풀이는 굳이 방문 없이 `index point`를 사용하여 문제를 풀어 갔다.
 - 또한 효율성검사를 위해, 루프문을 최대한 활용했다는 점에서 좋은 로직을 배웠다.
 - 게다가, 주어진 배열이 오름차순으로 정렬되어있기에 가능한 로직인걸 봐서, 제한사항도 최대한 활용하고 있음을 배웠다.
#### 유의사항
- 효율성 높이기
  - 효율성에서 가장 많이 잡아 먹는 부분은 Loop 개선
  - 적절한 데이터 구조 사용
  - 불필요한 오브젝트 제거****

<br>

### 11.17 step2_정렬
#### 지문 이해 및 풀이 계획강의
 - 숫자 -> 문자 -> 내림차순 -> 조합, 내가 생각했던 방식과 크게 다를 것이 없었다.
#### 강사의 풀이
 - 버블 소트를 사용했다.
 - 주어진 배열 변수가 모두 "0"으로만 이루어진 경우 예외처리를 별도로 해줬다. 전혀 생각해보지 못한 예외처리였다.
   - 하지만 그래도 60점, 그리고 런타임 에러가 난다. 
 - 런타임 에러가 나는 경우 대부분 2가지 경우이다.
   - 주어진 조건의 최대시간을 초과하여 연산이 진행되거나
   - 무한 루프가 돌아서 이다.
   - 나도 루프문이 느리다고 생각하였다.
 - 풀이과정과 refactoring 과정을 둘 다 보여준다.
   - 첫번째 풀이 comparator<String>으로 푼다. 문자열을 합쳐서 비교하는 것은 생각지도 못했다.
   - 두번째 풀이 comparator문을 람다식으로 바꾼다. 또한 charAt(0) -> startsWith() 로 바꾼다.
   - 세번째 풀이 IntStream을 사용해서 전체적인 정렬식을 바꾼다. 
 - 이번 강의는 풀이뿐만 아니라 라이브러리도 사용하면서 간단하게 리펙토링까지 하는 것이 놀라웠고 많이 배웠다.

   <br>

### 11.19 step3_이분탐색
 - 다른 강의 영상이라 스킵하였다.

<br>
<br>


## 다시 풀기

### 11.16 step1
 - 알게된 내용을 바탕으로 다시 기지국 문제를 리펙토링하였다. 
 - 쓸데없는 방문유무를 다 제거하고, for문 하나에 index를 활용하여 문제를 풀어보았다.

### 11.17 step2_정렬
 - 마법의 엘리베이터는 곧바로 풀었다. 
 - 가장 큰수는 다시 풀어도 실패한다고 뜬다.. 뭐가 잘못된건지 확인해봐야겠다.

### 11.19 step3_이분탐색
 - 공장관리 효율성 고려않아고 풀면 테스트1번이 통과하는데
 - 효율성 고려하여 이분탐색을 구현해서 풀면, 테스트1번이 실패한다.(그것도 시간초과이다.)
 - 확인해보니 최대/최소 걸리는 시간을 정할때
   - 목표량을 작업자 수로 나누면 소수점 버림이 생기는 것을 처리를 안해주니 이런 사태가 일어났다.
   - 1보다 작을 경우 처리만 생각했지, 1.9.. , 2.9등의 숫자에서 버림을 고려하지 못한 실수임 깨달았다.
   - `+1`로 처리해주니 모든 테스트가 통과하였다.